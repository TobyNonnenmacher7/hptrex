diff --git a/src/patternRecognition/TTPCHitPad.cxx b/src/patternRecognition/TTPCHitPad.cxx
index 6f00bef..64bdea3 100644
--- a/src/patternRecognition/TTPCHitPad.cxx
+++ b/src/patternRecognition/TTPCHitPad.cxx
@@ -2,7 +2,6 @@
 
 //ClassImp(trex::TTPCHitPad);
 
-//typedef std::vector< trex::THandle< trex::TSingleHit > >::const_iterator timebin;
 
 trex::TTPCHitPad::TTPCHitPad(double eDep, TLorentzVector pos4){
 
@@ -10,287 +9,4 @@ trex::TTPCHitPad::TTPCHitPad(double eDep, TLorentzVector pos4){
   fPosition=pos4.Vect();
   fTimeFit=pos4.T();
   
-//InitParameters();
 }
-
-
-void trex::TTPCHitPad::InitParameters(){
-
-}
-
-void trex::TTPCHitPad::Init(){
-
-/*  fNegativePeakBin = std::vector< trex::THandle<trex::TSingleHit> >();
-
-  // Saturation
-  fSaturation = 0;
-  if ( this->GetTimeUncertainty() > 1.1* fSamplingTime) {
-    fSaturation = int(this->GetTimeUncertainty() *2. / fSamplingTime);
-  }
-
-  fAtHoriEdge = trex::TGeomInfo::Get().TPC().PadIsAtHorEdge(this->GetGeomId());
-  fAtVertEdge = trex::TGeomInfo::Get().TPC().PadIsAtVerEdge(this->GetGeomId());
-
-  fHairCandidate = false;
-
-  fDriftSense = int(trex::TGeomInfo::Get().TPC().GetDriftSense( this->GetGeomId() ));
-
-  fChargeIntegral = 0.;
-  trex::THandle<trex::TMultiHit> mh = GetMultiHit();
-  int binNb = 0;
-  double maxCharge = -9999.;
-  for( timebin bin = mh->begin(); bin < mh->end(); bin++, binNb++){
-    fChargeIntegral += (*bin)->GetCharge();
-    if ((*bin)->GetCharge() > maxCharge){
-      fMaxPeak = binNb;
-      maxCharge = (*bin)->GetCharge();
-    }
-  }
-
-  fIsFitted = kWFPEAKNOFIT;
-  fChargeFit = -0xABCDEF;
-  fTimeFit = -0xABCDEF;
-  fSigmaFit = -0xABCDEF;
-
-  // By default do the analytic fit.
-  // The ROOT fit is available for studies but currently not considered
-  // usable because probably too slow.
-  AnalyticFit();*/
-}
-/*
-unsigned int trex::TTPCHitPad::GetNumberPeaks(){
-  return fPeakBin.size();
-}
-
-
-trex::THandle<trex::THit> trex::TTPCHitPad::GetMultiHit(){
-
-  if ( this->GetContributorCount() > 0 ){
-    return this->GetContributor(0);
-  } else {
-    return trex::THandle<trex::TMultiHit>();
-  }
-}
-
-
-void trex::TTPCHitPad::AnalyticFit() {
-
-  fIsFitted = kWFPEAKNOFIT;
-  fChargeFit = -0xABCDEF;
-  fTimeFit = -0xABCDEF;
-  fSigmaFit = -0xABCDEF;
-
-  // Only fit if there is only one peak in the hit.
-  if (fPeakBin.size() > 1){
-    return;
-  }
-
-  // Only perform analytic fit to peak if the peak is not saturated by more than 2 bins
-  // Saturation at or below 2 bins is not distinguishable.
-  if (fSaturation > 2){
-    return;
-  }
-
-  // Only do the fit if there is enough room around the peak.
-  trex::THandle<trex::TMultiHit> mh = GetMultiHit();
-  if ((unsigned int)(fMaxPeak + fAnalyticFitRange) > mh->size() || (fMaxPeak - fAnalyticFitRange) < 0) {
-    return;
-  }
-
-  // Check peak amplitude is large enough such that the fit can be
-  // performed confidently to produce an accurate arrival time
-  if (fCharge < fAnalyticFitAmpCut) {
-    return;
-  }
-
-  // Primary electrons:
-  double pe = 0.0;
-
-  // Sum variables used in calculation of mean:
-  double y = 0.0, // Sum_i y_i
-         x = 0.0,      // Sum_i x_i
-         x2 = 0.0,     // Sum_i x_i^2
-         x3 = 0.0,     // Sum_i x_i^3
-         x4 = 0.0,     // Sum_i x_i^4
-         yx = 0.0,     // Sum_i y_i*x_i
-         yx2 = 0.0,    // Sum_i y_i*x_i^2
-         n = 0.0,      // Sum 1
-         time,         // time bin
-         time2;        // time bin squared
-
-  typedef std::vector< trex::THandle< trex::TSingleHit > >::const_iterator iterator;
-  iterator maxBin = mh->begin() + fMaxPeak;
-
-  iterator start = maxBin - fAnalyticFitRange,
-           end = maxBin + fAnalyticFitRange;
-
-  // Calculation of sums:
-  for (iterator j = start; j != end; j++) {
-    pe = log((*j)->GetCharge());
-    time = (*j)->GetTime();
-    time2 = time*time;
-
-    n += 1.0;
-    y += pe;
-    x += time;
-    x2 += time2;
-    x3 += time2*time;
-    x4 += time2*time2;
-    yx += pe*time;
-    yx2 += pe*time2;
-  }
-
-  // Calculation of quantities obtained from matrix row reduction:
-  double b = x2 - x*x/n,
-         d = x3 - x2*x/n,
-         c = yx - x*y/n,
-         e = x3 - x2*x/n,
-         f = x4 - x2*x2/n,
-         g = yx2 - y*x2/n;
-
-  // Calculation of mean, sigma, and amplitude based on a0, a1, and a2:
-  double a2 = (g - e*c/b)/(f - e*d/b);
-  double a1 = (c - a2*d)/b;
-  double a0 = (y - a2*x2 - a1*x)/n;
-
-  double analyticArrivalTime = -a1/(2*a2);
-  double gaussianStDev = sqrt(-0.5/a2);
-  double gaussianAmp = exp(a0 + analyticArrivalTime*a1 + analyticArrivalTime*analyticArrivalTime*a2);
-
-  // Check success of fit based on the sigma of the gaussian. Inspection of fit
-  // results indicates that when the fit fails a good indication of the failure
-  // is a very large sigma, in excess of 1000.0 ns. Note the fitted location may
-  // still be within a couple time bins. AG 8/7/2012
-  if (gaussianStDev < 500.0) {
-    fIsFitted = kWFPEAKANALYTICFIT;
-    fChargeFit = gaussianAmp;
-    fTimeFit = analyticArrivalTime;
-    fSigmaFit = gaussianStDev;
-  }
-}
-
-
-void trex::TTPCHitPad::RootGaussFit() {
-
-  fIsFitted = kWFPEAKNOFIT;
-  fChargeFit = -0xABCDEF;
-  fTimeFit = -0xABCDEF;
-  fSigmaFit = -0xABCDEF;
-
-  if (fPeakBin.size() > 1){
-    return;
-  }
-
-  std::vector<double> at;
-  std::vector<double> aq;
-
-  trex::THandle<trex::TMultiHit> mh = GetMultiHit();
-
-  double localmaxADC = 0.0;
-  int idxmax=-1;
-  int idx=0;
-  double   Time=0;
-
-  typedef std::vector< trex::THandle< trex::TSingleHit > >::const_iterator iterator;
-  for( iterator mhit = mh->begin(); mhit !=  mh->end(); mhit++ ) {
-    if( localmaxADC < (*mhit)->GetCharge() ) {
-      localmaxADC = (*mhit)->GetCharge();
-      Time = (*mhit)->GetTime();
-      idxmax = idx;
-    }
-
-    at.push_back( (*mhit)->GetTime() );
-    aq.push_back( (*mhit)->GetCharge() );
-    idx++;
-  }
-
-  // see if we can get better time estimate, and pulse width estimate
-  int neachside=7;
-  int nfit=std::min<int>(2*neachside+1,at.size());
-  int idxmin = std::max<int>(0,idxmax-neachside);
-  int idxmaxmax = std::min<int>(at.size()-1,idxmin+nfit);
-  nfit = idxmaxmax-idxmin;
-
-  TGraph tg(nfit, &(at[idxmin]), &(aq[idxmin]) );
-  TF1 tf("tf","gaus",at[idxmin]-0.1,at[idxmaxmax]+0.1);
-  tf.SetParameters( localmaxADC, Time, 100.0 ); // set a reasonable first guess
-  tg.Fit(&tf,"");
-
-  double Tfit = tf.GetParameter(1);
-  double TSig = tf.GetParameter(2);
-  double Qfit = tf.GetParameter(0)/0.133; //fudge factor to make it similar to integral charge
-
-  // sanity check of fit.. if result yeilds
-  // insane value, maybe reject this point?
-  if ( ! (Tfit<at[idxmin] || Tfit>at[idxmaxmax] || Qfit<0.0) ){
-    fIsFitted = kWFPEAKROOTGAUSSFIT;
-    fChargeFit = Qfit;
-    fTimeFit = Tfit;
-    fSigmaFit = TSig;
-  }
-
-}
-*/
-
-std::vector<double> trex::TTPCHitPad::GetPeakTimes() {
-
-  //std::vector<double> PeakTimes;
-  //for (std::vector< trex::THandle< trex::TSingleHit > >::const_iterator bin = fPeakBin.begin(); bin !=  fPeakBin.end(); bin++) {
-  //  PeakTimes.push_back((*bin)->GetTime());
-  //}
-  //return PeakTimes;
-  std::vector<double> peakTimes;
-  peakTimes.push_back(fTimeFit);
-  return peakTimes;
-}
-
-
-std::vector<double> trex::TTPCHitPad::GetPeakCharges() {
-
-  std::vector<double> PeakCharges;
-//  for (std::vector< trex::THandle< trex::TSingleHit > >::const_iterator bin = fPeakBin.begin(); bin !=  fPeakBin.end(); bin++) {
-//    PeakCharges.push_back((*bin)->GetCharge());
-//  }
-  PeakCharges.push_back(fChargeFit);
-  return PeakCharges;
- 
-}
-/*
-
-std::vector<double> trex::TTPCHitPad::GetNegativePeakTimes() {
-
-  std::vector<double> negativePeakTimes;
-  for (std::vector< trex::THandle< trex::TSingleHit > >::const_iterator bin = fNegativePeakBin.begin(); bin !=  fNegativePeakBin.end(); bin++) {
-    negativePeakTimes.push_back((*bin)->GetTime());
-  }
-  return negativePeakTimes;
-}
-
-
-std::vector<double> trex::TTPCHitPad::GetNegativePeakCharges() {
-
-  std::vector<double> negativePeakCharges;
-  for (std::vector< trex::THandle< trex::TSingleHit > >::const_iterator bin = fNegativePeakBin.begin(); bin !=  fNegativePeakBin.end(); bin++) {
-    negativePeakCharges.push_back((*bin)->GetCharge());
-  }
-  return negativePeakCharges;
-}
-
-
-// void GetWaveformTimeRange(trex::THandle<trex::TReconHit> wf, double &min, double &max) {
-
-//   // Simple single peak
-//   if ( fPeakBin.size()){
-//       min = fTime - fLowerTimeSpread;
-//       max = fTime + fUpperTimeSpread;
-//   // Many close peaks. Use the TSingleHits saved for each peak
-//   } else {
-//     min = wf->GetContributor(2)->GetTime() - fLowerTimeSpread;
-//     max = wf->GetContributor(wf->GetContributorCount()-1)->GetTime() + fUpperTimeSpread;
-//   }
-// }
-
-trex::THandle<trex::TMultiHit> trex::TTPCHitPad::ConvertToOAEvent() {
-  return GetMultiHit();
-}
-*/
diff --git a/src/patternRecognition/TTPCHitPad.hxx b/src/patternRecognition/TTPCHitPad.hxx
index c4e7cd6..afcf37e 100644
--- a/src/patternRecognition/TTPCHitPad.hxx
+++ b/src/patternRecognition/TTPCHitPad.hxx
@@ -5,9 +5,6 @@
 #include "TVector3.h"
 #include "TLorentzVector.h"
 
-/// Possible sources of the T0
-enum {kWFPEAKNOFIT = 0, kWFPEAKANALYTICFIT, kWFPEAKROOTGAUSSFIT};
-
 namespace trex {
   class TTPCHitPad;
 }
@@ -18,55 +15,10 @@ namespace trex {
 class trex::TTPCHitPad {
 public:
   TTPCHitPad(double eDep, TLorentzVector pos4);
-  /// Returns a vector with the charge of each one the peaks in the waveform.
-  /// If there is only one peak, the given charge is the same as GetCharge().
-  std::vector<double> GetPeakCharges();
-  double GetCharge(){return GetPeakCharges()[0];}
-
-  /// Returns a vector with the time of each one the peaks in the waveform.
-  /// If there is only one peak, the given time is the same as GetTime().
-  std::vector<double> GetPeakTimes();
-  double GetTime(){return GetPeakTimes()[0];}
-
-  std::vector<double> GetNegativePeakTimes(){std::vector<double> dummy;return dummy;}
-  std::vector<double> GetNegativePeakCharges(){std::vector<double> dummy;return dummy;}
-
-  unsigned int GetNumberPeaks(){return 1;}
-  /// Return a vector with the charges of each of the negative peaks in the waveform
-  //  std::vector<double> GetNegativePeakCharges();
-  /// Return a vector with the times of each of the negative peaks in the waveform
-  //std::vector<double> GetNegativePeakTimes();
-
-  /// Number of bins with the same value at the highest peak.
-  /// A return value of 1 is for a peak considered not saturated.
-  int Saturation(){return fSaturation;};
-  int DriftSense(){return fDriftSense;};
-
-  /// Returns the charge integral for the waveform
-  /// as opposed to the height of the highest peak returned by GetCharge()
-  double ChargeIntegral(){return fChargeIntegral;};
-
-  /// Returns the extrapolated charge of the highest peak in the waveform
-  /// as opposed to the possibly saturated height returned by GetCharge()
-  double ChargeExtrapolated(){return fChargeExtrapolated;};
 
-  // Is this pad against the vertical edge of the MM ?
-  bool IsAtVertEdge(){return fAtVertEdge;};
-  // Is this pad against the horizontal edge of the MM ?
-  bool IsAtHoriEdge(){return fAtHoriEdge;};
+  double GetCharge(){return fChargeFit;}
 
-  /// Report if the peak of the waveform has been fitted and by which algorithm:
-  /// kWFPEAKNOFIT        -> No successful fit
-  /// kWFPEAKANALYTICFIT  -> Analytic fit
-  /// kWFPEAKROOTGAUSSFIT -> ROOT Gaussian fit
-  int IsFitted(){return fIsFitted;};
-
-  /// Returns the charge obtained from the fit to the peak
-  double ChargeFit(){return fChargeFit;};
-  /// Returns the time obtained from the fit to the peak
-  double TimeFit(){return fTimeFit;};
-  /// Returns the sigma obtained from the fit to the peak
-  double SigmaFit(){return fSigmaFit;};
+  double GetTime(){return fTimeFit;}
 
   /// Short cut to access the Y position of the pad
   double Y(){return fPosition.Y();};
@@ -76,40 +28,12 @@ public:
   TVector3 GetPosition(){return fPosition;}
 
 private:
-  /// Initialise member variables
-  void Init();
-  void InitParameters();
-
-  /// Index of the bin of maximum charge in the waveform
-  int fMaxPeak;
-  unsigned int fSaturation;
-  int fDriftSense;
-
-  bool fAtHoriEdge;
-  bool fAtVertEdge;
-
-  double fChargeIntegral;
-  double fChargeExtrapolated;
-
-  int fIsFitted;
 
   /// Amplitude for the peaks, as produced by the analytic gaussian fit (UNFIT if not fit)
   double fChargeFit;
+
   /// Fitted times for the peaks, as produced by the analytic gaussian fit (UNFIT if not fit)
   double fTimeFit;
-  /// Gaussian sigma from the peak fit (UNFIT if not fit)
-  double fSigmaFit;
-
-  /// tpcRecon.Reco.Wave.AnalyticFitRange
-  int fAnalyticFitRange;
-  /// tpcRecon.Reco.Wave.AnalyticFitAmpCut
-  double fAnalyticFitAmpCut;
-  /// tpcRecon.Reco.Wave.LowerTimeSpread
-  double fLowerTimeSpread;
-  /// tpcRecon.Reco.Wave.UpperTimeSpread
-  double fUpperTimeSpread;
-  /// tpcRecon.AfterTPC.SamplingTime
-  double fSamplingTime;
 
   TVector3 fPosition;
 };
diff --git a/src/patternRecognition/TTPCLayout.cxx b/src/patternRecognition/TTPCLayout.cxx
index 74199d1..345e60b 100644
--- a/src/patternRecognition/TTPCLayout.cxx
+++ b/src/patternRecognition/TTPCLayout.cxx
@@ -11,11 +11,9 @@ trex::TTPCLayout::TTPCLayout(){
   //MDH
   //PLACEHOLDER!!!
   // sampling time and drift speeds
-  fDriftSpeed = 1.;
   fPadPitchY = 1.;
   fPadPitchZ = 1.;
   fXCellSize = 1. * fPadPitchZ; 
-  fTWidth = fXCellSize / fDriftSpeed;
 
   // set useable pattern and path sizes
   fMinPatternPads = 4;
@@ -91,41 +89,10 @@ trex::TTPCLayout::TTPCLayout(){
 
   fAStarHeuristicFactor = 1.2;
   
-  // other default values
-  fTNMin = 0.;
-  fTNMax = -1.;
-  fTPMin = 0.;
-  fTPMax = -1.;
-  fTNegativeBins = 0;
-  fTPositiveBins = 0;
-  fTBins = 0;
 }
 trex::TTPCLayout::~TTPCLayout(){
 }
 
-void trex::TTPCLayout::SetTimeRanges(double tNMin, double tNMax, double tPMin, double tPMax){
-  fTNMin = tNMin;
-  fTNMax = tNMax;
-  fTPMin = tPMin;
-  fTPMax = tPMax;
-
-  bool binsN = tNMin < tNMax; // do hits exist in negative half?
-  bool binsP = tPMin < tPMax; // do hits exist in positibe half?
-
-  if(binsN){
-    fTNegativeBins = (int)( (fTNMax-fTNMin) / fTWidth );
-  }
-  else{
-    fTNegativeBins = 0;
-  };
-  if(binsP){
-    fTPositiveBins = (int)( (fTPMax-fTPMin) / fTWidth );
-  }
-  else{
-    fTPositiveBins = 0;
-  };
-  fTBins = fTNegativeBins + fTPositiveBins;
-}
 
 void trex::TTPCLayout::SetRanges(int minX,int maxX, int minY,int maxY, int minZ,int maxZ){
   // set x, y and z minima, maxima and sizes
@@ -160,7 +127,7 @@ long trex::TTPCLayout::SafeMash(int x, int y, int z){
   return Mash(x, y, z);
 }
 
-trex::TTPCCellInfo3D trex::TTPCLayout::GetPadPosID(TVector3 pos, double time, int tpcMask){
+trex::TTPCCellInfo3D trex::TTPCLayout::GetPadPosID(TVector3 pos, int tpcMask){
   trex::TTPCCellInfo3D cellInfo;
 
   //MDH
diff --git a/src/patternRecognition/TTPCLayout.hxx b/src/patternRecognition/TTPCLayout.hxx
index 1554674..27ac41d 100644
--- a/src/patternRecognition/TTPCLayout.hxx
+++ b/src/patternRecognition/TTPCLayout.hxx
@@ -45,50 +45,25 @@ namespace trex{
       /// Default destructor
       ~TTPCLayout();
 
-      // Set min and max times either side of the cathode
-      void SetTimeRanges(double tNMin, double tNMax, double tPMin, double tPMax);
       /// Set cell id ranges in x, y and z
       void SetRanges(int minX,int maxX, int minY,int maxY, int minZ,int maxZ);
-      /// Get cell id ranges in x, y and z
-      //void GetRanges(int& sizeX,int& minX,int& maxX, int& sizeY,int& minY,int& maxY, int& minZ,int& maxZ,int& sizeZ);
-      /// Get 2D cell ranges in x view, y view or z view, at axis of 1, 2 or 3 respectively
-      //void GetRanges(int& sizeX,int& minX,int& maxX, int& sizeY,int& minY,int& maxY, int axis=1);
 
       /// Get cell id in x, y and z based on a 3D position
-      trex::TTPCCellInfo3D GetPadPosID(TVector3 pos, double time, int tpcMask=-1);
+      trex::TTPCCellInfo3D GetPadPosID(TVector3 pos, int tpcMask=-1);
 
       /// Convert cell id in x, y and z to a single unique long integer
       long Mash(int x, int y, int z);
-      /// Convert cell id in y and z to a single unique long integer
-      //long MashYZ(int y, int z);
       /// Convert cell id in x, y and z to a single unique long integer, returning -1 if bad ids are supplied
       long SafeMash(int x, int y, int z);
-      /// Convert a single unique long integer into a cell id in x, y and z
-      //trex::TTPCCell3D UnMash(long id);
 
       /// Find appropriate distances for a given type of connection
       void GetTypeDistances(int& distX, int& distY, int& distZ, trex::TTPCConnection::Type type);
 
-      /// Get drift speed
-      double GetDriftSpeed(){ return fDriftSpeed; }
-
-      /// Get minimum hit time in negative half
-      double GetTNMin(){ return fTNMin; }
-      /// Get maximum hit time in negative half
-      double GetTNMax(){ return fTNMax; }
-      /// Get minimum hit time in positive half
-      double GetTPMin(){ return fTPMin; }
-      /// Get maximum hit time in positive half
-      double GetTPMax(){ return fTPMax; }
-
       /// Get distance between MM pad centres in y direction
       double GetPadPitchY(){ return fPadPitchY; }
       /// Get distance between MM pad centres in z direction
       double GetPadPitchZ(){ return fPadPitchZ; }
 
-      /// Get wheter a track in this event crosses the central cathode
-    //      bool GetXCathodeCross(){ return fXCathodeCross; }
-
       /// Get size of an individual x cell
       double GetXCellSize(){ return fXCellSize; }
 
@@ -190,24 +165,6 @@ namespace trex{
 
     private:
 
-      /// Drift speed
-      double fDriftSpeed;
-
-      /// Minimum hit time in negative half
-      double fTNMin;
-      /// Maximum hit time in negative half
-      double fTNMax;
-      /// Minimum hit time in positive half
-      double fTPMin;
-      /// Maximum hit time in positive half
-      double fTPMax;
-      /// Number of bins in negative half
-      int fTNegativeBins;
-      /// Number of bins in positibe half
-      int fTPositiveBins;
-      /// Total number of time bins
-      int fTBins;
-
       /// Distance between MM pad centres in y direction
       double fPadPitchY;
       // Distance between MM pad centres in z direction
@@ -224,8 +181,6 @@ namespace trex{
 
       /// Size of an individual x cell
       double fXCellSize;
-      /// Time bin size
-      double fTWidth;
 
       /// Minimum x id in event
       int fMinX;
diff --git a/src/patternRecognition/TTPCPathVolume.cxx b/src/patternRecognition/TTPCPathVolume.cxx
index b60206d..8bb3ac3 100644
--- a/src/patternRecognition/TTPCPathVolume.cxx
+++ b/src/patternRecognition/TTPCPathVolume.cxx
@@ -13,7 +13,6 @@ trex::TTPCPathVolume::TTPCPathVolume(trex::TTPCUnitVolume* unitVolume){
   fZMin = 0;
   fZMax = 0;
   fZSize = 0;
-  fAverageTime = 0.;
 
   fClosed = false;
   fIsXCluster = false;
@@ -100,7 +99,6 @@ void trex::TTPCPathVolume::Close(){
   fZMin = +999999;
   fZMax = -999999;
 
-  fAverageTime = 0.;
   fAveragePos = TVector3(0., 0., 0.);
   fAveragePosXYZ = TVector3(0., 0., 0.);
   int norm = 0;
@@ -114,7 +112,6 @@ void trex::TTPCPathVolume::Close(){
     fZMin = std::min(fZMin, frnd->GetZ());
     fZMax = std::max(fZMax, frnd->GetZ());
 
-    fAverageTime += frnd->GetTime();
     fAveragePos += frnd->GetPos();
     fAveragePosXYZ += frnd->GetPosXYZ();
     norm ++;
@@ -123,7 +120,6 @@ void trex::TTPCPathVolume::Close(){
   fYSize = (fYMax - fYMin) + 1;
   fZSize = (fZMax - fZMin) + 1;
 
-  fAverageTime /= double(norm);
   fAveragePos *= 1. / double(norm);
   fAveragePosXYZ *= 1. / double(norm);
 
diff --git a/src/patternRecognition/TTPCPathVolume.hxx b/src/patternRecognition/TTPCPathVolume.hxx
index 3e05740..8e62efc 100644
--- a/src/patternRecognition/TTPCPathVolume.hxx
+++ b/src/patternRecognition/TTPCPathVolume.hxx
@@ -85,8 +85,6 @@ namespace trex{
       int GetZMax(){ Close(); return fZMax;}
       /// Get spread in z
       int GetZSize(){ Close(); return fZSize;}
-      /// Get average time
-      double GetAverageTime(){ Close(); return fAverageTime; }
       /// Get average position
       TVector3 GetAveragePos(){ Close(); return fAveragePos; }
       /// Get average position in x, y and z
@@ -155,8 +153,6 @@ namespace trex{
       int fZMax;
       /// Spread in z
       int fZSize;
-      /// Average time
-      double fAverageTime;
       /// Average position
       TVector3 fAveragePos;
       /// Average position in x, y and z
diff --git a/src/patternRecognition/TTPCTRExPatAlgorithm.cxx b/src/patternRecognition/TTPCTRExPatAlgorithm.cxx
index 3bdbb3b..d87c706 100644
--- a/src/patternRecognition/TTPCTRExPatAlgorithm.cxx
+++ b/src/patternRecognition/TTPCTRExPatAlgorithm.cxx
@@ -42,48 +42,7 @@ void trex::TTPCTRExPatAlgorithm::CleanUp(){
 }
 
 void trex::TTPCTRExPatAlgorithm::PrepareHits(std::vector<trex::TTPCHitPad*>& hits){
-  // needed for pattern recognition - min and max times either side of the cathode
-  double tPMin = +99999999.;
-  double tPMax = -99999999.;
-  double tNMin = +99999999.;
-  double tNMax = -99999999.;
   fHits=hits;
-  for (std::vector<trex::TTPCHitPad*>::iterator hit = hits.begin(); hit != hits.end(); ++hit){
-    trex::TTPCHitPad* phit = *hit;
-
-    //MDH TODO - FIX CALL TO GEOM
-    // sense determines which side of the cathode we're on
-    //    int curX = int(trex::TGeomInfo::TPC().GetDriftSense(phit->GetGeomId()));
-    int curX=0;
-
-    // needed for pattern recognition - get min and max times either side of the cathode
-    std::vector<double> peakTimes = phit->GetPeakTimes();
-    if(peakTimes.size()){
-      for(std::vector<double>::iterator peakTimeIt = peakTimes.begin(); peakTimeIt != peakTimes.end(); ++peakTimeIt){
-        if(curX < 0){
-          tNMin = std::min(tNMin, *peakTimeIt);
-          tNMax = std::max(tNMax, *peakTimeIt);
-        }
-        else{
-          tPMin = std::min(tPMin, *peakTimeIt);
-          tPMax = std::max(tPMax, *peakTimeIt);
-        };
-      };
-    }
-    else{
-      if(curX < 0){
-        tNMin = std::min(tNMin, phit->GetTime());
-        tNMax = std::max(tNMax, phit->GetTime());
-      }
-      else{
-        tPMin = std::min(tPMin, phit->GetTime());
-        tPMax = std::max(tPMax, phit->GetTime());
-      };
-    };
-  };
-
-  // add maximum and minimum times either side of the cathode
-  fMasterLayout->SetTimeRanges(tNMin, tNMax, tPMin, tPMax);
 
   // work out minimum and maximum cell ids in x, y and z
   int minX = +99999;
@@ -95,12 +54,8 @@ void trex::TTPCTRExPatAlgorithm::PrepareHits(std::vector<trex::TTPCHitPad*>& hit
   for (std::vector<trex::TTPCHitPad*>::iterator hitIt = hits.begin(); hitIt != hits.end(); ++hitIt){
     trex::TTPCHitPad* hit = *hitIt;
 
-    //MDH
-    //Hopefully our hit object will have a GetTime method or else we need to abstract
-    //this out completely into a position number everywhere...
-
     // convert position to cell id in x, y and z
-    trex::TTPCCellInfo3D cell = fMasterLayout->GetPadPosID(hit->GetPosition(),hit->GetTime());
+    trex::TTPCCellInfo3D cell = fMasterLayout->GetPadPosID(hit->GetPosition());
 
     // find minima and maxima
     minX = std::min(minX, cell.x);
@@ -123,7 +78,7 @@ void trex::TTPCTRExPatAlgorithm::PrepareHits(std::vector<trex::TTPCHitPad*>& hit
     trex::TTPCHitPad* hit = *hitIt;
 
     // convert position to cell id in x, y and z
-    trex::TTPCCellInfo3D cell = fMasterLayout->GetPadPosID(hit->GetPosition(), 0);
+    trex::TTPCCellInfo3D cell = fMasterLayout->GetPadPosID(hit->GetPosition());
 
     // convert cell id in x, y and z to unique id
     long id = fMasterLayout->Mash(cell.x, cell.y, cell.z);
@@ -140,22 +95,7 @@ void trex::TTPCTRExPatAlgorithm::PrepareHits(std::vector<trex::TTPCHitPad*>& hit
       trex::TTPCUnitVolume& curVol = *(fMasterHitMap[id]);
 
       curVol.SetCell(cell.x, cell.y, cell.z, id);
-      //      if(cell.segX > 0){
-      curVol.SetTimeOffset(fMasterLayout->GetTPMin());
-	// }
-	//else{
-	//  curVol.SetTimeOffset(fMasterLayout->GetTNMin());
-	//};
-
-      // get MM information
-
-      //MDH TODO - figure out if any of this is needed
-      /*trex::TGeometryId geomId = hit->GetGeomId();
-    unsigned int tpc = trex::TGeomInfo::Get().TPC().GeomIdToTPC(geomId);
-    unsigned int half = trex::TGeomInfo::Get().TPC().GeomIdToHalf(geomId);
-    unsigned int mm = trex::TGeomInfo::Get().TPC().GeomIdToMM(geomId);
-    curVol.SetMMLoc(tpc, half, mm);
-      */
+
     };
     // increment charge and average position at this cell
     fMasterHitMap[id]->AddEvent(hit);
@@ -196,33 +136,40 @@ void trex::TTPCTRExPatAlgorithm::GetPatterns(trex::TReconObjectContainer *foundP
 
 void trex::TTPCTRExPatAlgorithm::Process(std::vector<trex::TTPCHitPad*>& hits, std::vector<trex::TTPCHitPad*>& used, std::vector<trex::TTPCHitPad*>& unused){
 
+  std::cout<<"2"<<std::endl;
   // master layout for all sub-events
   fMasterLayout = new trex::TTPCLayout();
-
+  std::cout<<"3"<<std::endl;
   // reset group IDs
   trex::TTPCVolGroup::ResetFreeID();
   // prepare hits
   PrepareHits(hits);
-
+  std::cout<<"4"<<std::endl;
   // master manager for all unit volumes
   fMasterVolGroupMan = new trex::TTPCVolGroupMan(fMasterLayout);
+  std::cout<<"5"<<std::endl;
+  std::cout<<"Number of hits: "<<fMasterHitMap.size()<<std::endl;
   fMasterVolGroupMan->AddPrimaryHits(fMasterHitMap);
-
+  std::cout<<"6"<<std::endl;
   // split all hits up into lists of sub events, with separate group for high charge ones if needed
   std::vector< trex::TTPCVolGroup > subEvents;
-  
+  std::cout<<"7"<<std::endl;
   fMasterVolGroupMan->GetConnectedHits(subEvents, trex::TTPCConnection::path);
-  
+  std::cout<<"8"<<std::endl;
+  std::cout<<"Number of subevents: "<<subEvents.size()<<std::endl;
   // push all groups of decent size into sub events
   for(unsigned int i=0; i<subEvents.size(); ++i){
+    std::cout<<"9"<<std::endl;
     trex::TTPCVolGroup& subEvent = subEvents.at(i);
-    
+    std::cout<<"10"<<std::endl;
     if(fMasterVolGroupMan->CheckUsability(subEvent)){
+      std::cout<<"11"<<std::endl;
       // create sub-algorithm for each sub-event
       fSubAlgorithms.emplace_back(fMasterLayout);
-
+      std::cout<<"12"<<std::endl;
       // set hit selection for sub-event
       fSubAlgorithms.back().SetUpHits(subEvent.GetHitMap());
+      std::cout<<"13"<<std::endl;
     };
   };
 
diff --git a/src/patternRecognition/TTPCUnitVolume.cxx b/src/patternRecognition/TTPCUnitVolume.cxx
index bf6bd78..e652350 100644
--- a/src/patternRecognition/TTPCUnitVolume.cxx
+++ b/src/patternRecognition/TTPCUnitVolume.cxx
@@ -4,15 +4,11 @@
 trex::TTPCUnitVolume::TTPCUnitVolume(){
 
   // initialise charge, hits and position to zero
-  fNegativePeakEarly = 0.;
-  fNegativePeakLate = 0.;
+  //fNegativePeakEarly = 0.;
+  //fNegativePeakLate = 0.;
   fQ = 0.;
   fQMax = 0.;
 
-  fTime = 0.;
-  fTimeNom = 0.;
-  fTimeMin = +99999999.;
-  fTimeMax = -99999999.;
   fHasPos = false;
   fFriendDist = 9999;
 
@@ -52,51 +48,9 @@ void trex::TTPCUnitVolume::AddEvent(trex::TTPCHitPad* hit){
   // position, charge and time
   TVector3 pos = hit->GetPosition();
   double q = hit->GetCharge();
-  double time = 0.;
-  double timeNom = 0.;
-
-  // set average, max and min times from hit peak times
-  std::vector<double> peakTimes = hit->GetPeakTimes();
-  if(peakTimes.size()){
-    time = 0.;
-    for(std::vector<double>::iterator peakTimeIt = peakTimes.begin(); peakTimeIt != peakTimes.end(); ++peakTimeIt){
-      double offPeakTime = *peakTimeIt - fTimeOffset;
-      fTimeMin = std::min(fTimeMin, offPeakTime);
-      fTimeMax = std::max(fTimeMax, offPeakTime);
-      timeNom += offPeakTime;
-      time += *peakTimeIt;
-    };
-    timeNom /= (double)peakTimes.size();
-    time /= (double)peakTimes.size();
-  }
-  else{
-    double offPeakTime = hit->GetTime() - fTimeOffset;
-    fTimeMin = std::min(fTimeMin, offPeakTime);
-    fTimeMax = std::max(fTimeMax, offPeakTime);
-    timeNom = offPeakTime;
-    time = hit->GetTime();
-  };
 
   // set charge weighted average position and time between old and input position
   fPos = ((fQ * fPos) + (q * pos)) * (1./(fQ + q));
-  fTimeNom = ((fQ * fTimeNom) + (q * timeNom)) * (1./(fQ + q));
-  fTime = ((fQ * fTime) + (q * time)) * (1./(fQ + q));
-
-  // also add negative peak charges before and after
-  std::vector<double> negativePeakCharges = hit->GetNegativePeakCharges();
-  std::vector<double> negativePeakTimes = hit->GetNegativePeakTimes();
-  unsigned int negativePeakN = negativePeakCharges.size();
-  for(unsigned int i=0; i<negativePeakN; ++i){
-    double negativeCharge = negativePeakCharges.at(i);
-    double negativeTime = negativePeakTimes.at(i);
-
-    if(negativeTime < time){
-      fNegativePeakEarly = std::min(fNegativePeakEarly, negativeCharge);
-    }
-    else if(negativeTime > time){
-      fNegativePeakLate = std::min(fNegativePeakLate, negativeCharge);
-    };
-  };
 
   // increment charge
   AddCharge(q);
@@ -117,37 +71,3 @@ trex::TTPCCellInfo3D trex::TTPCUnitVolume::GetCellInfo3D(){
 
   return padInfo;
 }
-
-int trex::TTPCUnitVolume::GetNPeaksSum(){
-  unsigned int peaksSum=0;
-  for(std::vector< trex::TTPCHitPad* >::iterator hitIt = fHits.begin(); hitIt != fHits.end(); ++hitIt){
-    trex::TTPCHitPad* hitPad = *hitIt;
-    peaksSum += hitPad->GetNumberPeaks();
-  }
-  return (int)peaksSum;
-}
-int trex::TTPCUnitVolume::GetNPeaksMax(){
-  unsigned int peaksSum=0;
-  for(std::vector< trex::TTPCHitPad* >::iterator hitIt = fHits.begin(); hitIt != fHits.end(); ++hitIt){
-    trex::TTPCHitPad* hitPad = *hitIt;
-    peaksSum = std::max(peaksSum, hitPad->GetNumberPeaks());
-  }
-  return (int)peaksSum;
-}
-int trex::TTPCUnitVolume::GetNSaturated(){
-  int nSat=0;
-  for(std::vector< trex::TTPCHitPad* >::iterator hitIt = fHits.begin(); hitIt != fHits.end(); ++hitIt){
-    trex::TTPCHitPad* hitPad = *hitIt;
-    nSat += (int)(hitPad->Saturation() > 1);
-  };
-  return nSat;
-}
-int trex::TTPCUnitVolume::GetSaturation(){
-  int satSum=0;
-  for(std::vector< trex::TTPCHitPad* >::iterator hitIt = fHits.begin(); hitIt != fHits.end(); ++hitIt){
-    trex::TTPCHitPad* hitPad = *hitIt;
-    satSum += hitPad->Saturation();
-  };
-  return satSum;
-}
-
diff --git a/src/patternRecognition/TTPCUnitVolume.hxx b/src/patternRecognition/TTPCUnitVolume.hxx
index 0c4e89d..39b28c9 100644
--- a/src/patternRecognition/TTPCUnitVolume.hxx
+++ b/src/patternRecognition/TTPCUnitVolume.hxx
@@ -38,15 +38,6 @@ namespace trex{
       /// Summarise position and edge status in one struct
       trex::TTPCCellInfo3D GetCellInfo3D();
 
-      /// Get total number of peaks
-      int GetNPeaksSum();
-      /// Get maximum number of peaks
-      int GetNPeaksMax();
-      /// Get number of saturated peaks
-      int GetNSaturated();
-      /// Get total saturation
-      int GetSaturation();
-
       /// Reset friends for association
       void ClearExtendedCell(bool isFocus=true);
 
@@ -69,14 +60,6 @@ namespace trex{
       TVector3 GetPos(){ return fPos;}
       /// Get cell index representation ov average position in this cell
       TVector3 GetPosXYZ(){ return TVector3( (double)fX, (double)fY, (double)fZ); }
-      /// Get average time in this cell
-      double GetTime(){ return fTime;}
-      /// Get offset average time in this cell
-      double GetTimeNom(){ return fTimeNom;}
-      /// Get minimum time in this cell
-      double GetTimeMin(){ return fTimeMin;}
-      /// Get maximum time in this cell
-      double GetTimeMax(){ return fTimeMax;}
 
       /// Get hits associated with this cell
       std::vector< trex::TTPCHitPad* > GetHits(){ return fHits;}
@@ -87,11 +70,6 @@ namespace trex{
       /// Get size of list of hits associated with this cell
       unsigned int size(){ return fHits.size();}
 
-      /// Get negative peak before this hit
-      double GetNegativePeakEarly(){ return fNegativePeakEarly; }
-      /// Get late peak before this hit
-      double GetNegativePeakLate(){ return fNegativePeakLate; }
-
       /// Get cell unique id
       long GetID(){ return fID;}
 
@@ -101,17 +79,12 @@ namespace trex{
       // setters
       /// Set total charge in this cell
       void SetQ(int q){ fQ = q;}
-      /// Set local time offset for x calculations
-      void SetTimeOffset(double timeOffset){ fTimeOffset = timeOffset; }
       /// Set distance from focus for building list
       void SetFriendDist(float friendDist){ fFriendDist = friendDist;}
 
 
     private:
 
-      /// Local time offset for x calculations
-      double fTimeOffset;
-
       /// Whether or not position is set
       bool fHasPos;
 
@@ -128,23 +101,10 @@ namespace trex{
       double fQMax;
       /// Average position in this cell
       TVector3 fPos;
-      /// Average time in this cell
-      double fTime;
-      /// Average offset time in this cell
-      double fTimeNom;
-      /// Minimum time in this cell
-      double fTimeMin;
-      /// Maximum time in this cell
-      double fTimeMax;
 
       /// Hits associated with this cell
       std::vector< trex::TTPCHitPad* > fHits;
 
-      /// Negative peak before this hit
-      double fNegativePeakEarly;
-      /// Late peak before this hit
-      double fNegativePeakLate;
-
       /// Cell unique id
       long fID;
 
diff --git a/src/patternRecognition/TTPCVolGroup.cxx b/src/patternRecognition/TTPCVolGroup.cxx
index 2312625..cce2505 100644
--- a/src/patternRecognition/TTPCVolGroup.cxx
+++ b/src/patternRecognition/TTPCVolGroup.cxx
@@ -24,7 +24,6 @@ trex::TTPCVolGroup::TTPCVolGroup(trex::TTPCLayout* layout, unsigned int id){
   fZSize = 0;
 
   fAveragePosition = TVector3();
-  fAverageTime = 0.;
   fAveragePad = trex::TTPCCellInfo3D();
   fSigmaPadX = 0.;
   fSigmaPadY = 0.;
diff --git a/src/patternRecognition/TTPCVolGroup.hxx b/src/patternRecognition/TTPCVolGroup.hxx
index 13b59d8..017cb41 100644
--- a/src/patternRecognition/TTPCVolGroup.hxx
+++ b/src/patternRecognition/TTPCVolGroup.hxx
@@ -92,8 +92,6 @@ class trex::TTPCVolGroup : public TObject {
     TVector3 GetAveragePosition(){ Close(); return fAveragePosition; }
     /// Get vector representing average cell x, y, z
     TVector3 GetAveragePosXYZ(){ Close(); return TVector3( (double)fAveragePad.x, (double)fAveragePad.y, (double)fAveragePad.z ); }
-    /// Return average time of all cells in the group 
-    double GetAverageTime(){ Close(); return fAverageTime; }
     /// Get the pad at the average position of all cells in the group
     trex::TTPCCellInfo3D GetAveragePad(){ Close(); return fAveragePad; }
     /// Get the unit volume at the average position of all cells in the group
@@ -212,8 +210,6 @@ class trex::TTPCVolGroup : public TObject {
 
     /// Average position of all cells in group
     TVector3 fAveragePosition;
-    /// Average time of all cells in group
-    double fAverageTime;
     /// Pad at average position of all cells in group
     trex::TTPCCellInfo3D fAveragePad;
     /// Unit volume at average position of all cells in group
diff --git a/src/patternRecognition/TTPCVolGroupMan.cxx b/src/patternRecognition/TTPCVolGroupMan.cxx
index 6405adb..c8b6a74 100644
--- a/src/patternRecognition/TTPCVolGroupMan.cxx
+++ b/src/patternRecognition/TTPCVolGroupMan.cxx
@@ -2293,25 +2293,12 @@ void trex::TTPCVolGroupMan::RecursiveFriendListSeek(long startID, trex::TTPCVolG
 }
 
 TVector3 trex::TTPCVolGroupMan::GetAvgPosRep(trex::TTPCPathVolume* vol){
-  //  double avgTime = vol->GetAverageTime();
   TVector3 avgPos = vol->GetAveragePos();
-  //  return TVector3(avgTime*fLayout->GetDriftSpeed(), avgPos.Y(), avgPos.Z());
   return avgPos;
 }
 TVector3 trex::TTPCVolGroupMan::GetAvgPosRep(trex::TTPCUnitVolume* vol, int sign){
-  /*  double avgTime;
-  if(sign < 0){
-    avgTime = vol->GetTimeMin();
-  }
-  else if(sign > 0){
-    avgTime = vol->GetTimeMax();
-  }
-  else{
-    avgTime = vol->GetTime();
-    };*/
   TVector3 avgPos = vol->GetPos();
   return avgPos;
-  //return TVector3(avgTime*fLayout->GetDriftSpeed(), avgPos.Y(), avgPos.Z());
 }
 
 bool trex::TTPCVolGroupMan::IsInRange(trex::TTPCPathVolume* point1, trex::TTPCPathVolume* point2, int sizeX, int sizeY, int sizeZ){
diff --git a/src/patternRecognition/TTPCVolGroupMan.hxx b/src/patternRecognition/TTPCVolGroupMan.hxx
index 03be683..2ff47f0 100644
--- a/src/patternRecognition/TTPCVolGroupMan.hxx
+++ b/src/patternRecognition/TTPCVolGroupMan.hxx
@@ -180,9 +180,9 @@ namespace trex{
       /// Filter out any remaining tracks and hits that don't make sense
       void SanityFilter(std::vector< trex::TTPCOrderedVolGroup >& input);
    
-      /// Get representation of position using time and co-ordinates
+      /// Get representation of position using co-ordinates
       TVector3 GetAvgPosRep(trex::TTPCPathVolume* vol);
-      /// Get representation of position using time and co-ordinates
+      /// Get representation of position using co-ordinates
       TVector3 GetAvgPosRep(trex::TTPCUnitVolume* vol, int sign=0);
 
       /// Get whether a specified cell is within a specified range of another
